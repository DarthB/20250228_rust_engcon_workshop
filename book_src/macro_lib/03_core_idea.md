# EngCon Core Idea

A generic type:

```rust
pub struct Validated<T: Validator + Sized> {
    inner: T,
}
```

is generated by a Validation trait:

```rust
pub trait Validator: Sized {
    /// Checks if the underlying data is valid and returns an [ValidationError] if not.
    ///
    /// Using the derive macro [Validatable] is recommended instead of a
    /// manual implemenation.
    fn validate(&self) -> Result<(), ValidationError>;

    /// tries to transform Self into a [Validated] may give an [ValidationError]
    fn try_into_validated(self) -> Result<Validated<Self>, ValidationError> {
        match self.validate() {
            Ok(_) => {
                // just checked if that is validated...
                let reval = unsafe { Validated::new_unchecked(self) };
                Ok(reval)
            }
            Err(err) => Err(err),
        }
    }
}
```

## Macros

Use a domain specific language based on macros to define the `Validator` trait togehter with an engineer:

```rust
use engcon::*;

#[derive(Debug, Clone, Default, Copy, PartialEq, Validatable)]
pub struct DistillationColumn {
    #[validate_value(x >= 3)]
    pub trays: i32,

    #[validate_value(x < trays, x >= 1)]
    pub feed_place: i32,

    #[validate_value(x > 0.0)]
    pub reflux_ratio: f32,

    #[validate_value(x > 0.0, x < 1.0)]
    pub distiliate_to_feed_ratio: f32,
}
```